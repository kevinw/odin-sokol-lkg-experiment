package preprocess

import "core:os"
using import "core:fmt"
import "core:mem"
import "core:odin/parser"
using import "core:odin/ast"
import "core:strings"

dirname :: proc(path: string, allocator := context.temp_allocator) -> string {
    assert(strings.index(path, "/") == -1, "need to handle forward slashes on windows");

    // if there's no slash, return ./
    last_index := strings.last_index(path, "\\");
    if last_index == -1 do return strings.clone(".\\", allocator);

    // if it's already a dir
    if last_index == len(path) - 1 do return strings.clone(path, allocator);

    // otherwise, return the dir part, including the slash
    return strings.clone(path[0:last_index + 1], allocator);
}

write_file_if_different :: proc(filename: string, contents: []u8) -> bool {
    size_on_disk := os.file_size_from_path(filename);

    file_differs := false;
    if size_on_disk == -1 {
        fmt.println(filename, " - new file");
        file_differs = true;
    } else if cast(i64)len(contents) != size_on_disk {
        fmt.println(filename, "different size");
        file_differs = true;
    } else {
        disk_contents, ok := os.read_entire_file(filename);
        if disk_contents != nil do defer delete(disk_contents);
        if !ok {
            fmt.println(filename, " - could not read");
            file_differs = true;
        }
        if 0 != mem.compare(disk_contents, contents) {
            fmt.println(filename, " - content differs");
            file_differs = true;
        }
    }

    if !file_differs do return false;

    os.write_entire_file(filename, contents);
    return true;
}

parse_odin_file :: proc(filename: string, p: ^parser.Parser) -> bool {
    assert(len(filename) > 0);
    assert(p != nil);

    data, success := os.read_entire_file(filename);
    if !success {
        fmt.eprintln("error reading", filename);
        return false;
    }

    pkg := mem.new_clone(ast.Package {
        kind = .Init,
        name="main",
        fullpath=dirname(filename),
    });

    file := mem.new_clone(ast.File{
        id=0, pkg=pkg, fullpath=filename, src=data,
    });

    files: [1]^ast.File = { file };
    pkg.files = files[:];

    res := parser.parse_file(p, file);
    if !res {
        fmt.eprintln("error parsing file", filename);
        return false;
    }

    return true;
}

delete_parser :: proc(p: ^parser.Parser) {
    if p != nil  && p.file != nil {
        if p.file.decls != nil {
            delete(p.file.decls);
        }
        if p.file.pkg_decl != nil {
            free(p.file.pkg_decl);
        }
    }
}

TWEAKABLE_ATTRIBUTE_NAME :: "tweak";

get_tweakable :: proc (value: ^Value_Decl) -> bool {
    for attr in value.attributes {
        if len(attr.elems) == 0 do continue;
        if len(attr.elems) > 1 {
            fmt.eprintln("warning: attribute has more than one element");
        } 
        attr_ident, attr_ok := attr.elems[0].derived.(Ident);
        if attr_ok && attr_ident.name == TWEAKABLE_ATTRIBUTE_NAME {
            return true;
        }
    }
    return false;
}

process_tweakable :: proc(builder: ^strings.Builder, value: ^Value_Decl) {
    assert(value.type == nil, "didn't expect to have a value type here");
    //fmt.println(value.values[0].derived);
    switch v in value.values[0].derived {
        case Comp_Lit:
            switch t in v.type.derived {
                case Ident:
                    switch t.name {
                        case "f32":
                        case "Vector3":
                            identifier_name := value.names[0].derived.(Ident).name;
                            sbprintf(builder, "    { \"%s\", proc() -> any { return &%s; } },\n", identifier_name, identifier_name);
                        case:
                            eprintln("unhandled tweakble type", t.name);
                    }
                case:
                    eprintln("unhandled value type in tweakable:");
                    eprintln(v.type.derived);
            }
        case:
            eprintln("error: unhandled value in process_tweakable");
    }
}

main :: proc() {
    defer free_all(context.temp_allocator);
    //
    // TWEAKABLES
    //

    using fmt;
    {
        p := parser.default_parser();
        fn := "c:\\src\\game\\src\\editor.odin";
        ok := parse_odin_file(fn, &p);
        assert(ok);

        builder := strings.make_builder(context.temp_allocator);
        defer strings.destroy_builder(&builder);
        sbprintln(&builder, "// AUTOGENERATED\n");
        sbprintln(&builder, "package main");
        using ast;
        sbprintln(&builder, "all_tweakables := [?]Tweakable {");

        for decl in p.file.decls {
            d: Value_Decl;
            if d, ok = decl.derived.(Value_Decl); !ok do continue;

            assert(len(d.names) == 1);
            ident := d.names[0].derived.(Ident);

            if get_tweakable(&d) {
                process_tweakable(&builder, &d);
                fmt.println("TWEAKABLE: ", ident.name);
            }
        }


        sbprintln(&builder, "};");

        write_file_if_different("src/tweakables.odin", builder.buf[:]);
    }

    //
    // SHADER METAPROGRAMMING
    //
    {
        p := parser.default_parser();
        parse_ok := parse_odin_file("c:\\src\\game\\src\\shader_globals.odin", &p);
        assert(parse_ok);

        using ast;

        builder := strings.make_builder(context.temp_allocator);
        defer strings.destroy_builder(&builder);

        sbprintf(&builder, "// AUTOGENERATED\n\n");

        for decl in p.file.decls {
            ok: bool;

            d: Value_Decl;
            if d, ok = decl.derived.(Value_Decl); !ok {
                continue;
            }

            assert(len(d.names) == 1);
            ident := d.names[0].derived.(Ident);

            struct_type: Struct_Type;
            if struct_type, ok = d.type.derived.(Struct_Type); !ok {
                continue;
            }

            sbprintf(&builder, "uniform %s {\n", ident.name);

            for field in struct_type.fields.list {
                for name in field.names {
                    field_ident := name.derived.(Ident);
                    switch field_type in field.type.derived {
                        case Ident:
                            switch field_type.name {
                                case "f32":
                                    sbprintf(&builder, "    float %s;\n", field_ident.name);
                                case:
                                    eprintln("unknown", field_type.name);
                            }
                        case:
                            eprintln("unhandled field_type", field_type);
                    }
                }
            }

            sbprintf(&builder, "};\n");
        }

        write_file_if_different("globals.glsl", builder.buf[:]);
    }

    println("preprocessor finished.");
}
